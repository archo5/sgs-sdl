// run this script from project root

include "io", "re", "string", "sgsmeta";

// read the API header
text = io_file_read( "ext/src/imgui/imgui.h" );

tokens = meta_tokens_parse( text );

// preprocess
for( i = 0; i < tokens.size; ++i )
{
	// preprocessor directives
	if( tokens[i].type == "#" )
	{
		j = i + 1;
		while( j < tokens.size && tokens[j].line == tokens[i].line )
			j++;
		tokens.erase( i, j - 1 );
		i--;
	}
	// known macros
	else if( tokens[i].type == "ident" && tokens[i].value == "IM_PRINTFARGS" )
	{
		assert( tokens[i+1].type == "(" );
		assert( tokens[i+2].type == "int" );
		assert( tokens[i+3].type == ")" );
		tokens.erase( i, i + 3 );
		i += 3;
	}
}

function dump_tokens( tokens )
{
	out = "";
	for i : ( tokens.size )
	{
		if( i > 0 )
		{
			if( tokens[ i ].line != tokens[ i - 1 ].line )
				out ..= "\n";
			else
				out ..= " ";
		}
		t = tokens[ i ];
		if( t.type == "ident" || t.type == "keyword" || t.type == "real" || t.type == "int" || t.type == "string" )
			out ..= t.value;
		else
			out ..= t.type;
	}
	return out;
}

function prev_tokens_until( tokens, i, check )
{
	end = i;
	while( i > 0 && check( tokens[ i ], i ) == false )
		i--;
	return tokens.part( i + 1, end - i - 1 );
}

function skip_until_brace_aware( tokens, i, check )
{
	stack = [];
	for( ; i < tokens.size; ++i )
	{
		t = tokens[i];
		if( stack.size == 0 && check( t, i ) )
			return i;
		if( t.type == "(" || t.type == "{" || t.type == "<" )
			stack.push( t.type );
		else if( t.type == ")" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "(" );
			stack.pop();
		}
		else if( t.type == "}" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "{" );
			stack.pop();
		}
		else if( t.type == ">" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "<" );
			stack.pop();
		}
	}
	assert( false );
}

// parse
NUMOVERLOADS = {};
GLOBALFUNCS = [];
REGINTS = {};
metaobj_set( REGINTS, _G );
eval = _G.eval;
bkG = _G;
for( i = 0; i < tokens.size; ++i )
{
	t = tokens[ i ];
	
	if( t.type == "ident" && t.value == "namespace" )
	{
		i++;
		assert( @tokens[i].type == "ident" );
		println( "Found namespace: ", tokens[i].value );
		assert( @tokens[i].value == "ImGui" );
		i++;
		assert( @tokens[i].type == "{" );
		i++;
		
		for( ; i < tokens.size; ++i )
		{
			// function definition search
			if( tokens[i].type == "}" )
				break;
			if( tokens[i].type == "(" && tokens[i-1].type == "ident" )
			{
				name = tokens[i-1].value;
				ret_type = prev_tokens_until( tokens, i - 1, function(t) = t.type == ";" || t.type == "{" || t.type == "}"; );
				while( @ret_type.first.value === "IMGUI_API" ||
					@ret_type.first.value == "static" )
					ret_type.shift();
				
				println( dump_tokens( ret_type ), "    ", name );
				
				i++;
				assert( i < tokens.size );
				
				newfunc = { name, ret_type, args = [] };
				GLOBALFUNCS.push( newfunc );
				@(NUMOVERLOADS[ name ] += 1);
				
				for(;;)
				{
					end = skip_until_brace_aware( tokens, i, function(t) = t.type == ")" || t.type == ","; );
					
					if( end != i )
					{
						println(">>>",dump_tokens(tokens.part(i,end-i)));
						if( end - i == 2 && tokens[i].type == "$" && tokens[i+1].type == "." )
						{
							argname = "<vararg>";
							argtype = [];
							argvalue = [];
						}
						else
						{
							asp = skip_until_brace_aware( tokens, i, function(t,i) use(end) = t.type == "=" || i == end; );
							
							argvalue = if( asp == end, [], tokens.part( asp + 1, end - asp - 1 ) );
							
						//	printvar(tokens[asp-1]);
							argtype = tokens.part( i, asp - i );
							if( tokens[ asp - 1 ].type == "ident" )
							{
								argname = tokens[ asp - 1 ].value;
								argtype.pop();
							}
							else // it might be a callback or an array
							{
								argname = null;
								start = i;
								for( i += 1; i < asp - 1; ++i )
								{
									if( ( i >= start + 2 && tokens[i-2].type == "(" && tokens[i-1].type == "*" && tokens[i].type == "ident" ) ||
										( tokens[i].type == "ident" && tokens[i+1].type == "[" ) )
									{
										argname = tokens[i].value;
										argtype.erase( i - start ); // remove name from type
										break;
									}
								}
								assert( argname !== null );
							}
						}
						
						newfunc.args.push({ name = argname, type = argtype, typestr = dump_tokens( argtype ), value = argvalue });
						println( "--- ", {name=argname, type=dump_tokens(argtype), val=dump_tokens(argvalue)} );
					}
					
					i = end + 1;
					if( tokens[end].type == ")" )
					{
						if( tokens[i].type == "{" )
						{
							i = skip_until_brace_aware( tokens, i, function(t) = t.type == "}"; );
						}
						break;
					}
				}
			}
		}
	}
	else if( t.type == "ident" && t.value == "enum" )
	{
		i++;
		assert( @tokens[i].type == "ident" );
		println( "Found enum: ", tokens[i].value );
		i++;
		assert( @tokens[i].type == "{" );
		i++;
		
		last_number = 0;
		while( i < tokens.size )
		{
			if( tokens[i].type == "}" )
				break;
			
			assert( tokens[i].type == "ident" );
			
			name = tokens[i].value;
			i++;
			assert( i < tokens.size );
			if( tokens[i].type == "=" )
			{
				i++;
				assert( i < tokens.size );
				
				start = i;
				while( tokens[i].type != "," && tokens[i].type != "}" )
					i++;
				
				value_tokens = tokens.part( start, i - start );
				
				value_token_str = dump_tokens( value_tokens );
				_G = REGINTS;
				value = eval( "return " .. value_token_str .. ";" );
				_G = bkG;
				last_number = toint( value );
			}
			REGINTS[ name ] = last_number++;
			
			if( tokens[i].type == "," )
				i++;
		}
	}
}

out = "\n#include \"imgui.hpp\"\n\n\n";

FUNCLIST = {};
foreach( func : GLOBALFUNCS )
{
	fn = func.name;
	ret_type = dump_tokens( func.ret_type );
	// these functions are not needed for us
	func.procstate = 0;
	if( fn == "ShowTestWindow" ) continue;
	if( fn == "ShowUserGuide" ) continue;
	if( fn == "ShowStyleEditor" ) continue;
	if( fn == "Value" ) continue;
	// obsolete functions
	func.procstate = 1;
	if( fn == "Begin" && func.args.size == 5 ) continue;
	// these functions are not done yet
	func.procstate = 2;
	if( fn == "GetIO" ) continue;
	if( fn == "GetStyle" ) continue;
	if( fn == "GetDrawData" ) continue;
	if( fn == "SetNextWindowSizeConstraints" ) continue;
	if( fn == "PushFont" ) continue;
	if( fn == "GetFont" ) continue;
	if( fn == "InputText" ) continue;
	if( fn == "InputTextMultiline" ) continue;
	if( fn == "GetWindowDrawList" ) continue;
	if( fn == "GetStateStorage" ) continue;
	if( fn == "SetStateStorage" ) continue;
	if( fn == "CreateContext" ) continue;
	if( fn == "DestroyContext" ) continue;
	if( fn == "GetCurrentContext" ) continue;
	if( fn == "SetCurrentContext" ) continue;
	
	func.procstate = 3;
	if( NUMOVERLOADS[ fn ] > 1 )
	{
		// special overload processing
		continue;
	}
	
	func.procstate = 4;
	Cname = "sgsimgui_" .. fn;
	SGSname = "ImGui_" .. fn;
	FUNCLIST[ SGSname ] = Cname;
	
	out ..= "static int " .. Cname .. "( SGS_CTX )\n{";
	out ..= "\n\tSGSFN( " .. sgson_encode( SGSname ) .. " );";
	
	preret = "";
	
	rvcount = 0;
	loadidx = 0;
	foreach( idx, arg : func.args )
	{
		tmpnm = "val" .. loadidx;
		if( arg.typestr == "bool *" )
		{
			out ..= "\n\tbool "..tmpnm.." = sgs_GetVar<bool>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushBool( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "float *" )
		{
			out ..= "\n\tfloat "..tmpnm.." = sgs_GetVar<float>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "float [ 2 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[2] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			rvcount += 2;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float [ 3 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[3] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[2] );";
			rvcount += 3;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float [ 4 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[4] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[2] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[3] );";
			rvcount += 4;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float &" )
		{
			out ..= "\n\tfloat "..tmpnm.." = sgs_GetVar<float>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = tmpnm;
		}
		else if( arg.typestr == "int *" )
		{
			out ..= "\n\tint "..tmpnm.." = sgs_GetVar<int>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "int [ 2 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[2] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			rvcount += 2;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "int [ 3 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[3] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[2] );";
			rvcount += 3;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "int [ 4 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[4] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[2] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[3] );";
			rvcount += 4;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "unsigned int *" )
		{
			out ..= "\n\tunsigned "..tmpnm.." = sgs_GetVar<unsigned>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "const ImVec2 &" )
		{
			arg.loader = "sgs_GetVar<ImVec2>()( C, " .. loadidx .. " )";
			loadidx += 2;
		}
		else if( arg.typestr == "const ImVec4 &" )
		{
			arg.loader = "sgs_GetVar<ImVec4>()( C, " .. loadidx .. " )";
			loadidx += 4;
		}
		else if( @func.args[ idx + 1 ].name == "<vararg>" )
		{
			arg.loader = "\"%s\"";
		}
		else
		{
			argty = if( arg.name == "<vararg>", "const char*", arg.typestr );
			arg.loader = "sgs_GetVar<" .. argty .. ">()( C, " .. loadidx++ .. " )";
		}
	}
	
	callstr = "\n\t";
	if( ret_type != "void" )
	{
		rvcount++;
		callstr ..= "sgs_PushVar( C, ";
		if( ret_type == "ImVec2" )
			rvcount++;
	}
	callstr ..= "ImGui::" .. fn .. "(";
	foreach( idx, arg : func.args )
	{
		if( idx > 0 )
			callstr ..= ",";
		callstr ..= "\n\t\t" .. arg.loader;
	}
	if( ret_type == "void" )
		callstr ..= "\n\t);";
	else
		callstr ..= "\n\t) );";
	out ..= callstr;
	
	out ..= preret;
	
	out ..= "\n\treturn " .. rvcount .. ";";
	out ..= "\n}\n\n";
}

out ..= "\nstatic sgs_RegFuncConst imgui_fconsts[] =\n{";
foreach( key, value : FUNCLIST )
{
	out ..= "\n\t{ " .. sgson_encode( key ) .. ", " .. value .. " },";
}
out ..= "\n\t{ NULL, NULL }";
out ..= "\n};\n\n";

out ..= "\nstatic sgs_RegIntConst imgui_iconsts[] =\n{";
foreach( key, value : REGINTS )
{
	out ..= "\n\t{ " .. sgson_encode( key ) .. ", " .. value .. " },";
}
out ..= "\n\t{ NULL, 0 }";
out ..= "\n};\n\n";

out ..= "\nvoid sgs_imgui_bind( SGS_CTX )\n{";
out ..= "\n\tsgs_RegFuncConsts( C, imgui_fconsts, -1 );";
out ..= "\n\tsgs_RegIntConsts( C, imgui_iconsts, -1 );";
out ..= "\n};\n\n";

io_file_write( "src/imgui_bind.cpp", out );


fn_stat_names = [
	"unneeded",
	"obsolete",
	"unimplemented (basic)",
	"unimplemented (overloaded)",
	"available",
];
fn_stat_values = [ 0, 0, 0, 0, 0 ];
foreach( func : GLOBALFUNCS )
{
	fn_stat_values[ func.procstate ]++;
}
println( "--- statistics ---" );
println( "// global" );
println( "- # enum values: ", dict_size( REGINTS ) );
println( "// namespace ImGui" );
for i : (5)
{
	println( "- [func] ", fn_stat_names[ i ], ": ", fn_stat_values[ i ] );
}

