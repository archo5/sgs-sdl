// run this script from project root

include "io", "re", "string", "sgsmeta";

// read the API header
text = io_file_read( "ext/src/imgui/imgui.h" );

tokens = meta_tokens_parse( text );

// preprocess
for( i = 0; i < tokens.size; ++i )
{
	// preprocessor directives
	if( tokens[i].type == "#" )
	{
		j = i + 1;
		while( j < tokens.size && tokens[j].line == tokens[i].line )
			j++;
		tokens.erase( i, j - 1 );
		i--;
	}
	// known macros
	else if( tokens[i].type == "ident" && tokens[i].value == "IM_PRINTFARGS" )
	{
		assert( tokens[i+1].type == "(" );
		assert( tokens[i+2].type == "int" );
		assert( tokens[i+3].type == ")" );
		tokens.erase( i, i + 3 );
		i += 3;
	}
}

function dump_tokens( tokens )
{
	out = "";
	for i : ( tokens.size )
	{
		if( i > 0 )
		{
			if( tokens[ i ].line != tokens[ i - 1 ].line )
				out ..= "\n";
			else
				out ..= " ";
		}
		t = tokens[ i ];
		if( t.type == "ident" || t.type == "keyword" || t.type == "real" || t.type == "int" || t.type == "string" )
			out ..= t.value;
		else
			out ..= t.type;
	}
	return out;
}

function prev_tokens_until( tokens, i, check )
{
	end = i;
	while( i > 0 && check( tokens[ i ], i ) == false )
		i--;
	return tokens.part( i + 1, end - i - 1 );
}

function skip_until_brace_aware( tokens, i, check )
{
	stack = [];
	for( ; i < tokens.size; ++i )
	{
		t = tokens[i];
		if( stack.size == 0 && check( t, i ) )
			return i;
		if( t.type == "(" || t.type == "{" || t.type == "<" )
			stack.push( t.type );
		else if( t.type == ")" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "(" );
			stack.pop();
		}
		else if( t.type == "}" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "{" );
			stack.pop();
		}
		else if( t.type == ">" )
		{
			assert( stack.size != 0 );
			assert( stack.last == "<" );
			stack.pop();
		}
	}
	assert( false );
}

// parse
NUMOVERLOADS = {};
GLOBALFUNCS = [];
REGINTS = {};
metaobj_set( REGINTS, _G );
eval = _G.eval;
bkG = _G;
for( i = 0; i < tokens.size; ++i )
{
	t = tokens[ i ];
	
	if( t.type == "ident" && t.value == "namespace" )
	{
		i++;
		assert( @tokens[i].type == "ident" );
		println( "Found namespace: ", tokens[i].value );
		assert( @tokens[i].value == "ImGui" );
		i++;
		assert( @tokens[i].type == "{" );
		i++;
		
		for( ; i < tokens.size; ++i )
		{
			// function definition search
			if( tokens[i].type == "}" )
				break;
			if( tokens[i].type == "(" && tokens[i-1].type == "ident" )
			{
				name = tokens[i-1].value;
				ret_type = prev_tokens_until( tokens, i - 1, function(t) = t.type == ";" || t.type == "{" || t.type == "}"; );
				while( @ret_type.first.value === "IMGUI_API" ||
					@ret_type.first.value == "static" ||
					@ret_type.first.value == "inline" )
					ret_type.shift();
				
				println( dump_tokens( ret_type ), "    ", name );
				
				i++;
				assert( i < tokens.size );
				
				newfunc = { name, ret_type, args = [] };
				GLOBALFUNCS.push( newfunc );
				@(NUMOVERLOADS[ name ] += 1);
				
				for(;;)
				{
					end = skip_until_brace_aware( tokens, i, function(t) = t.type == ")" || t.type == ","; );
					
					if( end != i )
					{
						println(">>>",dump_tokens(tokens.part(i,end-i)));
						if( end - i == 2 && tokens[i].type == "$" && tokens[i+1].type == "." )
						{
							argname = "<vararg>";
							argtype = [];
							argvalue = [];
						}
						else
						{
							asp = skip_until_brace_aware( tokens, i, function(t,i) use(end) = t.type == "=" || i == end; );
							
							argvalue = if( asp == end, [], tokens.part( asp + 1, end - asp - 1 ) );
							
						//	printvar(tokens[asp-1]);
							argtype = tokens.part( i, asp - i );
							if( tokens[ asp - 1 ].type == "ident" )
							{
								argname = tokens[ asp - 1 ].value;
								argtype.pop();
							}
							else // it might be a callback or an array
							{
								argname = null;
								start = i;
								for( i += 1; i < asp - 1; ++i )
								{
									if( ( i >= start + 2 && tokens[i-2].type == "(" && tokens[i-1].type == "*" && tokens[i].type == "ident" ) ||
										( tokens[i].type == "ident" && tokens[i+1].type == "[" ) )
									{
										argname = tokens[i].value;
										argtype.erase( i - start ); // remove name from type
										break;
									}
								}
								assert( argname !== null );
							}
						}
						
						newfunc.args.push({ name = argname, type = argtype, typestr = dump_tokens( argtype ), value = argvalue });
						println( "--- ", {name=argname, type=dump_tokens(argtype), val=dump_tokens(argvalue)} );
					}
					
					i = end + 1;
					if( tokens[end].type == ")" )
					{
						if( tokens[i].type == "{" )
						{
							i = skip_until_brace_aware( tokens, i + 1, function(t) = t.type == "}"; ) + 1;
						}
						break;
					}
				}
				
				ovrname = name .. "(";
				foreach( arg : newfunc.args )
				{
					if( arg !== newfunc.args.first )
						ovrname ..= ", ";
					ovrname ..= arg.typestr;
				}
				newfunc.ovrname = ovrname .. ")";
			}
		}
	}
	else if( t.type == "ident" && t.value == "enum" )
	{
		i++;
		assert( @tokens[i].type == "ident" );
		println( "Found enum: ", tokens[i].value );
		i++;
		assert( @tokens[i].type == "{" );
		i++;
		
		last_number = 0;
		while( i < tokens.size )
		{
			if( tokens[i].type == "}" )
				break;
			
			assert( tokens[i].type == "ident" );
			
			name = tokens[i].value;
			i++;
			assert( i < tokens.size );
			if( tokens[i].type == "=" )
			{
				i++;
				assert( i < tokens.size );
				
				start = i;
				while( tokens[i].type != "," && tokens[i].type != "}" )
					i++;
				
				value_tokens = tokens.part( start, i - start );
				
				value_token_str = dump_tokens( value_tokens );
				_G = REGINTS;
				value = eval( "return " .. value_token_str .. ";" );
				_G = bkG;
				last_number = toint( value );
			}
			REGINTS[ name ] = last_number++;
			
			if( tokens[i].type == "," )
				i++;
		}
	}
}

out = "\n#include \"imgui.hpp\"\n\n\n";

FUNCLIST = {};
foreach( func : GLOBALFUNCS )
{
	fn = func.name;
	ret_type = dump_tokens( func.ret_type );
	// these functions are not needed for us
	func.procstate = 0;
	if( @func.args.last.type[0].value == "va_list" ) continue;
	// obsolete functions
	func.procstate = 1;
	if( fn == "Begin" && func.args.size == 5 ) continue;
	if( fn == "CollapsingHeader" && func.args.size == 4 ) continue;
	if( fn == "GetWindowFont" ) continue;
	if( fn == "GetWindowFontSize" ) continue;
	if( fn == "SetScrollPosHere" ) continue;
	if( fn == "GetWindowCollapsed" ) continue;
	if( fn == "IsRectClipped" ) continue;
	// these functions are not done yet
	func.procstate = 2;
	if( fn == "GetIO" ) continue;
	if( fn == "GetStyle" ) continue;
	if( fn == "GetDrawData" ) continue;
	if( fn == "ShowStyleEditor" ) continue;
	if( fn == "SetNextWindowSizeConstraints" ) continue;
	if( fn == "PushFont" ) continue;
	if( fn == "GetFont" ) continue;
	if( fn == "InputText" ) continue;
	if( fn == "InputTextMultiline" ) continue;
	if( fn == "GetWindowDrawList" ) continue;
	if( fn == "GetStateStorage" ) continue;
	if( fn == "SetStateStorage" ) continue;
	if( fn == "CreateContext" ) continue;
	if( fn == "DestroyContext" ) continue;
	if( fn == "GetCurrentContext" ) continue;
	if( fn == "SetCurrentContext" ) continue;
	
	func.procstate = 3;
	if( NUMOVERLOADS[ fn ] > 1 )
	{
		// special overload processing
		// - separate by changing name
		if( fn == "Begin" ){ /* other version is obsolete */ }
		else if( fn == "SetWindowPos" ){ if( func.args.size == 2 ) fn = "SetCurrentWindowPos"; }
		else if( fn == "SetWindowSize" ){ if( func.args.size == 2 ) fn = "SetCurrentWindowSize"; }
		else if( fn == "SetWindowCollapsed" ){ if( func.args.size == 2 ) fn = "SetCurrentWindowCollapsed"; }
		else if( fn == "SetWindowFocus" ){ if( func.args.size == 0 ) fn = "SetCurrentWindowFocus"; }
		else if( fn == "CollapsingHeader" ){ if( func.args.size == 3 ) fn ..= "Closeable"; }
		else if( fn == "Value" )
		{
			t = func.args[1].typestr;
			if( t == "bool" ) fn ..= "B";
			else if( t == "int" ) fn ..= "I";
			else if( t == "unsigned int" ) fn ..= "U";
			else if( t == "float" ) fn ..= "F";
			else continue;
		}
		else if( fn == "ValueColor" ){ if( func.args[1].typestr != "ImU32" ) fn = "ValueColorF"; }
		else if( fn == "PushStyleVar" ){ fn ..= if( func.args[1].typestr == "float", "F", "V2" ); }
		else if( fn == "ListBoxHeader" ){ if( func.args[1].typestr == "int" ) fn ..= "2"; }
		else if( fn == "IsRectVisible" ){ if( func.args.size == 2 ) fn ..= "Screen"; }
		// - one implementation includes another
		else if( fn == "TreePush" ){ if( func.args[0].typestr == "const char *" ){ func.procstate = 4; continue; } }
		else if( fn == "Selectable" ){ if( func.args[1].typestr == "bool" ){ func.procstate = 4; continue; } }
		else if( fn == "MenuItem" ){ if( func.args[2].typestr == "bool" ){ func.procstate = 4; continue; } }
		// - custom coalescing implementation
		else if( fn == "PushID" )
		{
			if( !pushid_handled )
			{
				out ..= "static int sgsimgui_PushID( SGS_CTX )\n{";
				out ..= "\n\tSGSFN( \"ImGui_PushID\" );";
				out ..= "\n\tImGui::PushID( sgs_GetPtr( C, 0 ) );"; // strings are interned, so can save time by not hashing contents and using unique pointer instead
				out ..= "\n\treturn 0;";
				out ..= "\n}\n\n";
				FUNCLIST[ "ImGui_PushID" ] = "sgsimgui_PushID";
				pushid_handled = true;
			}
			func.procstate = 4;
			continue;
		}
		else if( fn == "GetID" )
		{
			if( !getid_handled )
			{
				out ..= "static int sgsimgui_GetID( SGS_CTX )\n{";
				out ..= "\n\tSGSFN( \"ImGui_GetID\" );";
				out ..= "\n\tsgs_PushInt( C, ImGui::GetID( sgs_GetPtr( C, 0 ) ) );"; // strings are interned, so can save time by not hashing contents and using unique pointer instead
				out ..= "\n\treturn 1;";
				out ..= "\n}\n\n";
				FUNCLIST[ "ImGui_GetID" ] = "sgsimgui_GetID";
				getid_handled = true;
			}
			func.procstate = 4;
			continue;
		}
		else if( fn == "RadioButton" )
		{
			if( !radiobutton_handled )
			{
				out ..= "static int sgsimgui_RadioButton( SGS_CTX )\n{";
				out ..= "\n\tSGSFN( \"ImGui_RadioButton\" );";
				out ..= "\n\tsgs_SizeVal ssz = sgs_StackSize( C );";
				out ..= "\n\tif( ssz == 2 ){ sgs_PushBool( C, ImGui::RadioButton( sgs_GetVar<const char*>()( C, 0 ), sgs_GetInt( C, 1 ) ) ); return 1; }";
				out ..= "\n\telse if( ssz == 3 )\n\t{";
				out ..= "\n\t\tint val = sgs_GetInt( C, 1 );";
				out ..= "\n\t\tsgs_PushBool( C, ImGui::RadioButton( sgs_GetVar<const char*>()( C, 0 ), &val, sgs_GetInt( C, 2 ) ) );";
				out ..= "\n\t\tsgs_PushInt( C, val );";
				out ..= "\n\t\treturn 2;\n\t}";
				out ..= "\n\telse return sgs_Msg( C, SGS_WARNING, \"expected 2 or 3 arguments, got %d\", ssz );";
				out ..= "\n}\n\n";
				FUNCLIST[ "ImGui_RadioButton" ] = "sgsimgui_RadioButton";
				radiobutton_handled = true;
			}
			func.procstate = 4;
			continue;
		}
		else if( fn == "TreeNode" )
		{
			if( !treenode_handled )
			{
				out ..= "static int sgsimgui_TreeNode( SGS_CTX )\n{";
				out ..= "\n\tSGSFN( \"ImGui_TreeNode\" );";
				out ..= "\n\tsgs_SizeVal ssz = sgs_StackSize( C );";
				out ..= "\n\tif( ssz == 1 ){ sgs_PushBool( C, ImGui::TreeNode( sgs_GetVar<const char*>()( C, 0 ) ) ); return 1; }";
				out ..= "\n\telse if( ssz == 2 ){ sgs_PushBool( C, ImGui::TreeNode( sgs_GetVar<void*>()( C, 0 ), \"%s\", sgs_GetVar<const char*>()( C, 1 ) ) ); return 1; }";
				out ..= "\n\telse return sgs_Msg( C, SGS_WARNING, \"expected 1 or 2 arguments, got %d\", ssz );";
				out ..= "\n}\n\n";
				FUNCLIST[ "ImGui_TreeNode" ] = "sgsimgui_TreeNode";
				treenode_handled = true;
			}
			func.procstate = 4;
			continue;
		}
		else if( fn == "TreeNodeEx" )
		{
			if( !treenodeex_handled )
			{
				out ..= "static int sgsimgui_TreeNodeEx( SGS_CTX )\n{";
				out ..= "\n\tSGSFN( \"ImGui_TreeNodeEx\" );";
				out ..= "\n\tsgs_SizeVal ssz = sgs_StackSize( C );";
				out ..= "\n\tif( ssz == 2 ){ sgs_PushBool( C, ImGui::TreeNodeEx( sgs_GetVar<const char*>()( C, 0 ), sgs_GetInt( C, 1 ) ) ); return 1; }";
				out ..= "\n\telse if( ssz == 3 ){ sgs_PushBool( C, ImGui::TreeNodeEx( sgs_GetVar<void*>()( C, 0 ), sgs_GetInt( C, 1 ), \"%s\", sgs_GetVar<const char*>()( C, 2 ) ) ); return 1; }";
				out ..= "\n\telse return sgs_Msg( C, SGS_WARNING, \"expected 1 or 2 arguments, got %d\", ssz );";
				out ..= "\n}\n\n";
				FUNCLIST[ "ImGui_TreeNodeEx" ] = "sgsimgui_TreeNodeEx";
				treenodeex_handled = true;
			}
			func.procstate = 4;
			continue;
		}
		else
		{
			continue;
		}
	}
	
	func.procstate = 4;
	Cname = "sgsimgui_" .. fn;
	SGSname = "ImGui_" .. fn;
	FUNCLIST[ SGSname ] = Cname;
	
	out ..= "static int " .. Cname .. "( SGS_CTX )\n{";
	out ..= "\n\tSGSFN( " .. sgson_encode( SGSname ) .. " );";
	
	preret = "";
	
	rvcount = 0;
	loadidx = 0;
	foreach( idx, arg : func.args )
	{
		tmpnm = "val" .. loadidx;
		if( arg.typestr == "bool *" )
		{
			out ..= "\n\tbool "..tmpnm.." = sgs_GetVar<bool>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushBool( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "float *" )
		{
			out ..= "\n\tfloat "..tmpnm.." = sgs_GetVar<float>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "float [ 2 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[2] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			rvcount += 2;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float [ 3 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[3] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[2] );";
			rvcount += 3;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float [ 4 ]" )
		{
			out ..= "\n\tfloat "..tmpnm.."[4] = { sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<float>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[2] );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.."[3] );";
			rvcount += 4;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "float &" )
		{
			out ..= "\n\tfloat "..tmpnm.." = sgs_GetVar<float>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushReal( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = tmpnm;
		}
		else if( arg.typestr == "int *" )
		{
			out ..= "\n\tint "..tmpnm.." = sgs_GetVar<int>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "int [ 2 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[2] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			rvcount += 2;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "int [ 3 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[3] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[2] );";
			rvcount += 3;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "int [ 4 ]" )
		{
			out ..= "\n\tint "..tmpnm.."[4] = { sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ),";
			out ..= " sgs_GetVar<int>()( C, " .. loadidx++ .. " ) };";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[0] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[1] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[2] );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.."[3] );";
			rvcount += 4;
			arg.loader = ""..tmpnm.."";
		}
		else if( arg.typestr == "unsigned int *" )
		{
			out ..= "\n\tunsigned "..tmpnm.." = sgs_GetVar<unsigned>()( C, " .. loadidx++ .. " );";
			preret ..= "\n\tsgs_PushInt( C, "..tmpnm.." );";
			rvcount += 1;
			arg.loader = "&"..tmpnm.."";
		}
		else if( arg.typestr == "const ImVec2 &" )
		{
			arg.loader = "sgs_GetVar<ImVec2>()( C, " .. loadidx .. " )";
			loadidx += 2;
		}
		else if( arg.typestr == "const ImVec4 &" )
		{
			arg.loader = "sgs_GetVar<ImVec4>()( C, " .. loadidx .. " )";
			loadidx += 4;
		}
		else if( @func.args[ idx + 1 ].name == "<vararg>" )
		{
			arg.loader = "\"%s\"";
		}
		else
		{
			argty = if( arg.name == "<vararg>", "const char*", arg.typestr );
			arg.loader = "sgs_GetVar<" .. argty .. ">()( C, " .. loadidx++ .. " )";
		}
	}
	
	out ..= "\n\t";
	if( ret_type != "void" )
	{
		rvcount++;
		out ..= "sgs_PushVar( C, ";
		if( ret_type == "ImVec2" )
			rvcount++;
	}
	out ..= "ImGui::" .. func.name .. "(";
	foreach( idx, arg : func.args )
	{
		if( idx > 0 )
			out ..= ",";
		out ..= "\n\t\t" .. arg.loader;
	}
	if( loadidx != 0 )
		out ..= "\n\t";
	if( ret_type != "void" )
		out ..= ") ";
	out ..= ");";
	
	out ..= preret;
	
	out ..= "\n\treturn " .. rvcount .. ";";
	out ..= "\n}\n\n";
}

out ..= "\nstatic sgs_RegFuncConst imgui_fconsts[] =\n{";
foreach( key, value : FUNCLIST )
{
	out ..= "\n\t{ " .. sgson_encode( key ) .. ", " .. value .. " },";
}
out ..= "\n\t{ NULL, NULL }";
out ..= "\n};\n\n";

out ..= "\nstatic sgs_RegIntConst imgui_iconsts[] =\n{";
foreach( key, value : REGINTS )
{
	out ..= "\n\t{ " .. sgson_encode( key ) .. ", " .. value .. " },";
}
out ..= "\n\t{ NULL, 0 }";
out ..= "\n};\n\n";

out ..= "\nvoid sgs_imgui_bind( SGS_CTX )\n{";
out ..= "\n\tsgs_RegFuncConsts( C, imgui_fconsts, -1 );";
out ..= "\n\tsgs_RegIntConsts( C, imgui_iconsts, -1 );";
out ..= "\n};\n\n";

io_file_write( "src/imgui_bind.cpp", out );


fn_stat_names = [
	"unneeded",
	"obsolete",
	"!! unimplemented",
	"!! unresolved overloaded",
	"+ available",
];
fn_stat_values = [ 0, 0, 0, 0, 0 ];
fn_printed_set = {};
foreach( func : GLOBALFUNCS )
{
	if( !isset( fn_printed_set, func.ovrname ) )
	{
		if( func.procstate < 4 )
			println( fn_stat_names[ func.procstate ], ": ", func.ovrname );
		fn_printed_set[ func.ovrname ] = true;
	}
	fn_stat_values[ func.procstate ]++;
}
println( "--- statistics ---" );
println( "// global" );
println( "- # enum values: ", dict_size( REGINTS ) );
println( "// namespace ImGui" );
for i : (5)
{
	println( "- [func] ", fn_stat_names[ i ], ": ", fn_stat_values[ i ] );
}

