
// CACHES

function SS3D_GetVertexDecl( ss3d, decl )
{
	if( !isset( ss3d.store, "vdecls" ) ) ss3d.store.vdecls = {};
	vdecls = ss3d.store.vdecls;
	if( !isset( vdecls, decl ) )
		vdecls[ decl ] = inst = ss3d.createVertexDecl( decl );
	else
		inst = vdecls[ decl ];
	return inst;
}

// SHADERS

function _SS3D_Shader_NamePath( name )
{
	name = string_replace( name, "\\", "/" );
	parts = string_explode( name, "/" );
	parts.pop();
	return string_implode( parts, "/" );
}

function _SS3D_Shader_ParseIncludes( renderer, name, data )
{
	path = _SS3D_Shader_NamePath( name );
	pos = data.length;
	while( ( pos = string_find_rev( data, "#include", pos ) ) !== null )
	{
		pos2a = string_find( data, "\n", pos );
		pos2b = string_find( data, "\r", pos );
		if( pos2a && ( !pos2b || pos2a < pos2b ) )
			pos2 = pos2a;
		else
			pos2 = pos2b;
		cut = string_cut( data, pos + 8, pos2 - 1 );
		cut = string_trim( cut, "\" " );
		
		guts = _SS3D_Shader_LoadFile( renderer, path $ "/" $ cut );
		data = string_part( data, 0, pos ) $ guts $ string_part( data, pos2 );
	}
	return data;
}

function _SS3D_Shader_LoadFile( renderer, name )
{
	filename = "shaders_" $ renderer $ "/" $ name $ ".shd";
	if( !io_file_exists( filename ) )
		return null;
	data = io_file_read( filename );
	data = _SS3D_Shader_ParseIncludes( renderer, name, data );
	return data;
}

function _SS3D_Shader_LoadCode( renderer, name )
{
	if( string_part( name, 0, 4 ) == "mtl:" )
	{
		info = string_explode( name, ":" );
		if( info.size != 3 )
			return WARNING( "invalid material name, expected mtl:<name>:<type>" );
		return string_replace
		(
			_SS3D_Shader_LoadFile( renderer, "tpl_mtl_" $ info[2] ),
			"__CODE__",
			_SS3D_Shader_LoadFile( renderer, "mtl_" $ info[1] )
		);
	}
	return _SS3D_Shader_LoadFile( renderer, name );
}


// MESH GEN

global cSS3D_GenMeshVertexFormat = "pf30f2nf3tf4cf4";
global cSS3D_GenParticleVertexFormat = "pf30f2cf4";

function SS3D_CreateCubeMesh( ss3d, material, extents, position, color )
{
	(vdata,idata,vcount,icount) = SS3D_MeshGen_Cube( extents, position, color );
	mesh = ss3d.createMesh();
	mesh.setVertexData( vdata, SS3D_GetVertexDecl( ss3d, cSS3D_GenMeshVertexFormat ), false );
	mesh.setIndexData( idata, false );
	mesh.numParts = 1;
	mesh.setPart( 0, material, 0, vcount, 0, icount );
	return mesh;
}

function SS3D_UpdateParticleMesh( ss3d, mesh, material, viewmatrix, positions, sizes, colors, angles )
{
	(vdata,idata,vcount,icount) = SS3D_MeshGen_Particles( viewmatrix, positions, sizes, colors, angles );
	
	if( mesh.vertexDataSize < vdata.length )
		mesh.initVertexBuffer( vdata.length );
	mesh.updateVertexData( vdata, SS3D_GetVertexDecl( ss3d, cSS3D_GenParticleVertexFormat ), false );
	
	if( mesh.indexDataSize < idata.length )
		mesh.initIndexBuffer( idata.length, false );
	mesh.updateIndexData( idata );
	
	mesh.numParts = 1;
	mesh.setPart( 0, material, 0, vcount, 0, icount );
}
