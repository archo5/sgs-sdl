
include_file( "engine/utils.sgs" );


global Tilemap = {};

function Tilemap.create( texture, tileWidth, tileHeight )
{
	return class
	({
		texture = texture,
		tileW = tileWidth,
		tileH = tileHeight,
		tiles = {},
		mesh = null,
		revid = 1,
		vfmt = make_vertex_format( "|pf2tf2cf4" ),
	},
	Tilemap );
}

function Tilemap.get( x, y )
{
	key = x + y * 0xffff;
	if( isset( this.tiles, key ) )
		return this.tiles[ key ];
	return null;
}

function Tilemap.set( x, y, tx, ty, col3or4 )
{
	key = x + y * 0xffff;
	this.tiles[ key ] = [ x, y, tx, ty, col3or4 ];
	this.revid++;
}

function Tilemap.checkCache()
{
	if( !this.revid )
		return;

	P = [], T = [], C = [];
	tw = this.tileW;
	th = this.tileH;
	itw = 1.0 / this.texture.width;
	ith = 1.0 / this.texture.height;
	mesh = "";
	foreach( tile : this.tiles )
	{
		x = tile[0] * tw;
		y = tile[1] * th;
		tx = tile[2] * tw * itw;
		ty = tile[3] * th * itw;
		tx1 = tx + tw * itw;
		ty1 = ty + th * itw;
		col = tile[4];
		if( col.size < 4 )
			col.push( 1.0 );
		mesh $= fmt_pack( "8f8f8f8f",
			x, y, tx, ty, col[0], col[1], col[2], col[3],
			x+tw, y, tx1, ty, col[0], col[1], col[2], col[3],
			x+tw, y+th, tx1, ty1, col[0], col[1], col[2], col[3],
			x, y+th, tx, ty1, col[0], col[1], col[2], col[3] );
	}
	this.mesh = mesh;
	this.revid = 0;
}

function Tilemap.render()
{
	this.checkCache();
	/*
	if( !xform )
		xform = { position = [0,0] };
	xform.mode = PT_QUADS;
	xform.texture = this.texture;
	xform.vertices = this.mesh[ 0 ];
	xform.vtexcoords = this.mesh[ 1 ];
	xform.vcolors = this.mesh[ 2 ];

	draw( xform );
	*/
	draw_packed( this.texture, this.vfmt, this.mesh,
		0, this.mesh.length / 32, PT_QUADS );
}
