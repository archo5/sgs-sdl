
include_file( "engine/font.sgs" );
include_file( "engine/draw.sgs" );


global _efn = function(){};


global UIControl =
{
	/* references */
	parent = null,
	
	/* states */
	clicked = false,
	mouseon = false,
	
	/* processing */
	on_draw = null,
};

/* DEFAULT events */
UIControl.onclick = _efn;
UIControl.onmousemove = _efn;
UIControl.onattach = _efn;
function UIControl.onhittest( x, y )
{
	return this.x <= x && this.x + this.w >= x
		&& this.y <= y && this.y + this.h >= y;
}
function UIControl.onenter(){ this.mouseon = true; }
function UIControl.onleave(){ this.mouseon = false; }
function UIControl.onmousedown( x, y, bid ){ if( this.mouseon && bid == 1 ) this.clicked = true; }
function UIControl.onmouseup(){ if( this.clicked && this.mouseon ) this.onclick(); this.clicked = false; }
function UIControl.onresize( w, h ){ foreach( c : this.children ) c.onresize( w, h ); }
function UIControl.globalmousedown( x, y, bid ){ foreach( c : this.children ) c.globalmousedown( x, y, bid ); }
function UIControl.globalmouseup( x, y, bid ){ foreach( c : this.children ) c.globalmouseup( x, y, bid ); }

/* PROCESSING */
function UIControl.get_ctrl_at( x, y )
{
	for( var i = this.children.size - 1; i >= 0; --i )
	{
		var sub = this.children[ i ].get_ctrl_at( x, y );
		if( sub !== null )
			return sub;
	}
	if( this.onhittest( x, y ) )
		return this;
	return null;
}
function UIControl.addChild( ch )
{
	ch.parent = this;
	this.children.push( ch );
	ch.onattach();
	return ch;
}

function UIControl.create( override )
{
	var data = { children = [] };
	data.font = create_font( "verdana.ttf", 12 );
	foreach( k, v : override )
		data[ k ] = v;
	return class( data, UIControl );
}


function ui_default_paint_button()
{
	mon = this.mouseon; if( this.clicked ) mon = 0;
	tex = this.textures[ mon + this.clicked * 2 ];
	draw_button( tex, this.x, this.x + this.w, this.y, this.y + this.h );

	draw_text_rect( this.name, this.font, [0.9,1], DT_CENTER | DT_VCENTER,
		this.x + 8, this.x + this.w - 8, this.y + 9, this.y + this.h - 7 );
	draw_text_rect( this.name, this.font, [0.1,1], DT_CENTER | DT_VCENTER,
		this.x + 8, this.x + this.w - 8, this.y + 8, this.y + this.h - 8 );
}

function UIControl.createButton( name, x, y, w, h, onclick )
{
	return UIControl.create
	({
		name = name,
		type = "button",
		x = x,
		y = y,
		w = w,
		h = h,
		onclick = onclick,
		on_draw = ui_default_paint_button,
		textures =
		[
			create_texture( "engine/img/buttonN.png" ),
			create_texture( "engine/img/buttonH.png" ),
			create_texture( "engine/img/buttonC.png" ),
		],
	});
}



function ui_default_paint_menu()
{
	var _scl = [ 200, 1 ];

	draw({ preset = "tile", position = [ this.x, this.y ],
		scale = [ this.w, this.h ], color = [ 0.8, 0.8, 0.8 ] });
	
	foreach( iid, item : this.items )
	{
		if( item.visible && item.inview )
		{
			x = this.x + item.x;
			y = this.y + 2;
			w = item.width;
			h = item.height;
			tex = this.textures[ this.open_item == iid ];
			if( item.mouseon || iid == this.open_item )
				draw_button( tex, x, x + w, y, y + h, 4, 4 );
			draw_text_rect( item.name, this.font, [0.1,1], DT_CENTER | DT_VCENTER, x, x + w, y - 2, y + h - 2 );

			if( iid == this.open_item )
			{
				draw({ preset = "tile", position = [ x, y + h ],
					scale = [ 200, 24 * item.ch.size + 4 ], color = [ 0.7, 0.7, 0.7 ] });
				foreach( siid, subitem : item.ch )
				{
					sx1 = x + 32;
					sx2 = sx1 + 160;
					sy1 = y + h + 2 + 24 * siid;
					sy2 = sy1 + 20;
					if( subitem.name )
					{
						if( siid == 1 )
						{
							tex = this.textures[ 0 ];
							draw_button( tex, x, x + 200, sy1, sy1 + 24, 4, 4 );
						}
						draw_text_rect( subitem.name, this.font, [0.1,1], DT_LEFT | DT_VCENTER, sx1, sx2, sy1, sy2 );
					}
					else
					{
						draw({ preset = "tile", position = [ x, sy1 + 11 ], scale = _scl, color = [ 0.6, 0.6, 0.6 ] });
						draw({ preset = "tile", position = [ x, sy1 + 12 ], scale = _scl, color = [ 0.8, 0.8, 0.8 ] });
					}
				}
			}
		}
	}
}

function UICreateMenuItem( name, onclick, icon )
{
	return
	{
		ch = [],
		icon = icon,
		name = name,
		onclick = onclick,
		visible = true,
		mouseon = false,
		clicked = false,
	};
}

function UIControl.createMenu()
{
	var UIMenu =
	{
		type = "button",
		x = 0,
		y = 0,
		w = 9999,
		h = 24,
		on_draw = ui_default_paint_menu,

		textures =
		[
			create_texture( "engine/img/menuitemH.png" ),
			create_texture( "engine/img/menuitemC.png" ),
		],

		items = [],
		open_item = -1,
	};

	function UIMenu.onattach()
	{
		this.w = this.parent.w;
	}

	function UIMenu.onresize( w, h )
	{
		this.w = this.parent.w;
		this._super.onresize.thiscall( this, w, h );
	}

	function UIMenu.onmousemove( x, y )
	{
		foreach( iid, item : this.items )
		{
			x1 = item.x + this.x;
			x2 = x1 + item.width;
			item.mouseon = x >= x1 && x <= x2;
			if( item.mouseon && this.open_item >= 0 )
				this.open_item = iid;
		}
	}
	function UIMenu.onmousedown( x, y, bid )
	{
		if( bid != 1 )
			return;
		foreach( iid, item : this.items )
		{
			if( item.mouseon )
			{
				item.clicked = true;
				if( this.open_item == iid )
					this.open_item = -1;
				else
					this.open_item = iid;
			}
		}
	}
	function UIMenu.onmouseup()
	{
		foreach( item : this.items )
		{
			if( item.clicked )
			{
				if( item.onclick )
					item.onclick();
				item.clicked = false;
			}
		}
	}
	function UIMenu.globalmousedown( x, y )
	{
		btnhit = false;
		vhit = y >= this.y && y <= this.y + this.h;
		foreach( iid, item : this.items )
		{
			btnhit ||= item.mouseon && vhit;
			if( iid == this.open_item )
			{
				x1 = this.x + item.x;
				x2 = x1 + 200;
				y1 = this.y + 2 + item.height;
				y2 = y1 + 24 * item.ch.size + 4;
				btnhit ||= x >= x1 && x <= x2 && y >= y1 && y <= y2;
			}
		}
		if( !btnhit )
			this.open_item = -1;
	}

	function UIMenu.onleave()
	{
		foreach( item : this.items )
			item.mouseon = false;
	}

	function UIMenu.recalcLayout()
	{
		x = 0;
		xe = this.x + this.w;

		foreach( item : this.items )
		{
			x += 2;
			item.x = x;
			item.width = get_text_length( item.name, this.font ) + 24;
			item.height = this.font.size + 8;
			x += item.width;
			item.inview = x <= this.w;
		}
	}

	function UIMenu.addItem( item )
	{
		this.items.push( item );
		return item;
	}

	return UIControl.create( UIMenu );
}


global UIFrame =
{
	name = "__frame__",
	type = "frame",
	x = 0,
	y = 0,
	w = 9999,
	h = 9999,
	
	curhover = null,
	curclick = null,
};

function UIFrame.event( e )
{
	if( e.type == SDL_VIDEORESIZE )
	{
		this.w = e.w;
		this.h = e.h;
		this.onresize( e.w, e.h );
	}
	if( e.type == SDL_MOUSEMOTION )
	{
		var ctrl = this.get_ctrl_at( e.x, e.y );
		if( ctrl !== this.curhover )
		{
			if( this.curhover !== null )
				this.curhover.onleave();
			this.curhover = ctrl;
			if( ctrl !== null )
				ctrl.onenter();
		}
		if( ctrl !== null )
			ctrl.onmousemove( e.x, e.y );
	}
	if( e.type == SDL_MOUSEBUTTONDOWN || e.type == SDL_MOUSEBUTTONUP )
	{
		var ctrl = this.get_ctrl_at( e.x, e.y );
		if( e.type == SDL_MOUSEBUTTONDOWN )
		{
			this.globalmousedown( e.x, e.y, e.button );
			if( ctrl !== null )
				ctrl.onmousedown( e.x, e.y, e.button );
			this.curclick = ctrl;
		}
		else
		{
			this.globalmouseup( e.x, e.y, e.button );
			if( ctrl !== null )
				ctrl.onmouseup( e.x, e.y, e.button );
			if( this.curclick !== null && ctrl !== this.curclick )
				this.curclick.onmouseup( e.x, e.y, e.button );
			this.curclick = null;
		}
	}
}

function UIFrame.draw()
{
	set_camera_ui( this.x, this.x+this.w, this.y, this.y+this.h );
	foreach( ch : this.children )
	{
		if( ch.on_draw )
			ch.on_draw();
	}
}

function UIFrame.create( w, h )
{
	var f = clone( UIFrame );
	f.w = w;
	f.h = h;
	return UIControl.create( f );
}
