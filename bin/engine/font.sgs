

global
	DT_LEFT    = 0b00000001,
	DT_CENTER  = 0b00000010,
	DT_RIGHT   = 0b00000100,
	DT_JUSTIFY = 0b00001000,
	DT_TOP     = 0b00010000,
	DT_VCENTER = 0b00100000,
	DT_BOTTOM  = 0b01000000;


function calc_text_layout( text_ucp, font, width, height )
{
	lines = [].reserve(6); // TODO optimize to static instance
	lineheight = font.size;
	
	SP = string_charcode( " " );
	NL = string_charcode( "\n" );
	
	from = 0;
	eol = 0;
	curline = 0;
	curword = 0;
	numwords = 1;
	pcpos = null;
	for( i = 0; i < text_ucp.size; ++i )
	{
		c = text_ucp[ i ];
		prevchar = null;
		if( pcpos != null )
			prevchar = text_ucp[ pcpos ];
		cw = font.get_advance( prevchar, text_ucp[ i ] );
		
		if( c == NL )
		{
			curline += curword;
			if( prevchar == SP )
				numwords--;
			
		//	lines.push({ from = from, to = i, width = curline, numwords = numwords });
			lines.push( from, i, curline );
			
			curline = 0;
			curword = 0;
			numwords = 1;
			if( ( lines.size + 1 ) * lineheight > height )
				break;
			pcpos = null;
			i++;
			while( i < text_ucp.size && text_ucp[ i ] == SP )
				i++;
			from = i--;
			continue;
		}
		if( c == SP )
		{
			curline += curword;
			if( prevchar !== null && prevchar != SP )
				numwords++;
			eol = i;
			curword = 0;
		}
		if( curline + curword + cw < width )
		{
			// still within line
			curword += cw;
			pcpos = i;
			continue;
		}
		else
		{
			// over the limit
			if( curline )
			{
				// if not first word, commit line and restart the word
				curword = 0;
				numwords--;
				i = eol;
			}
			curline += curword;
			
		//	lines.push({ from = from, to = i, width = curline, numwords = numwords });
			lines.push( from, i, curline );
			
			curline = 0;
			curword = 0;
			numwords = 1;
			if( ( lines.size + 1 ) * lineheight > height )
				break;
			pcpos = null;
			while( i < text_ucp.size && text_ucp[ i ] == SP )
				i++;
			from = i--;
			continue;
		}
	}
	
	curline += curword;
	if( curline )
	{
	//	lines.push({ from = from, to = text_ucp.size, width = curline, numwords = numwords });
		lines.push( from, text_ucp.size, curline );
	}
	
	return lines;
}

function draw_text_rect( text, font, color, placement, left, right, top, bottom )
{
	// validation
	if( !is_font( font ) )
	{
		WARNING( "draw_text(): invalid value for 'font'" );
		return false;
	}
	hfc = !!( placement & DT_LEFT ) + !!( placement & DT_CENTER )
		+ !!( placement & DT_RIGHT ) + !!( placement & DT_JUSTIFY );
	vfc = !!( placement & DT_TOP ) + !!( placement & DT_VCENTER )
		+ !!( placement & DT_BOTTOM );
	if( hfc != 1 || vfc != 1 )
	{
		WARNING( "draw_text(): invalid placement flag combo" );
		return false;
	}
	
	// sizing
	width = right - left;
	height = bottom - top;
	
	lineheight = font.size;
	if( height < lineheight )
		return true;
	
	text_ucp = string_utf8_decode( text );
	
	lines = calc_text_layout( text_ucp, font, width, height );
	
	vspace = height - lines.size * lineheight;
	y = top;
	if( placement & DT_VCENTER ) y += vspace / 2;
	else if( placement & DT_BOTTOM ) y += vspace;
	
//	foreach( lnum, line : lines )
	for( clo = 0; clo < lines.size; clo += 3 )
	{
		hspace = width - lines[clo+2];//line.width;
		x = left;
		if( placement & DT_CENTER ) x += hspace / 2;
		else if( placement & DT_RIGHT ) x += hspace;
		
		ucppart = text_ucp.part( lines[clo], lines[clo+1] - lines[clo] );
	//	ucppart = text_ucp.part( line.from, line.to - line.from );
		utf8part = string_utf8_encode( ucppart );
		
		draw_text_line_vn( utf8part, font, x, y, color );
		y += lineheight;
	}
}
